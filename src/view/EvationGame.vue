<template>
  <router-link to="/" class="home-button-corner">
    <button>Home„Å∏ÈÅ∑Áßª</button>
  </router-link>

  <div class="game-container">
    <canvas id="gameCanvas" ref="gameCanvas"></canvas>
  </div>
</template>

<script>
import { ref, onMounted, onUnmounted } from 'vue';

export default {
  name: 'EvationGame',
  setup() {
    const gameCanvas = ref(null);
    let canvas;
    let ctx;

    // --- ÂÆöÊï∞ ---
    const PLAYER_SIZE = 5;
    const PLAYER_SPEED = 5;
    const MAX_HP = 5;
    const INITIAL_ENEMY_SPAWN_INTERVAL = 30; // Èõ£ÊòìÂ∫¶1„ÅÆÊôÇ„ÅÆ„Çπ„Éù„Éº„É≥ÈñìÈöî („Éï„É¨„Éº„É†Êï∞)
    const BASE_ENEMY_SPEED = 3; // Èõ£ÊòìÂ∫¶1„ÅÆÊôÇ„ÅÆÂü∫Êú¨Êïµ„Çπ„Éî„Éº„Éâ
    const INVULNERABILITY_TIME = 1000;

    // ÂøÖÊÆ∫ÊäÄ„ÅÆÂÆöÊï∞
    const SPECIAL_ATTACK_INTERVAL = 10000; // 10Áßí„Åî„Å® („Éü„É™Áßí)
    const SPECIAL_ATTACK_DURATION = 3000; // ÂøÖÊÆ∫ÊäÄ„ÅÆÁ∂ôÁ∂öÊôÇÈñì (3Áßí)
    // ‚òÖ ÂøÖÊÆ∫ÊäÄ„ÅÆ„Çµ„Ç§„Éâ„Åî„Å®„ÅÆÂºæÊï∞„Éô„Éº„Çπ„ÄÇ„Åì„Åì„ÇíË™øÊï¥„Åô„Çã„Å®ÂÖ®‰Ωì„Å´ÂΩ±Èüø„Åó„Åæ„Åô„ÄÇ
    const BASE_BULLETS_PER_SIDE = 60;
    // const SPECIAL_BULLET_SPEED = 3; // „Çπ„Éî„Éº„Éâ„ÅØ„É≠„Ç∏„ÉÉ„ÇØÂÜÖ„Åß‰Ωø„Çè„Çå„Åæ„Åô„Åå„ÄÅÂÆöÊï∞Âåñ„Åó„Å¶„Åä„Åç„Åæ„Åô

    // --- „É™„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Å™Áä∂ÊÖã„Å®ÈÄöÂ∏∏„ÅÆÂ§âÊï∞ ---
    let playerX = ref(0);
    let playerY = ref(0);
    let playerHP = ref(MAX_HP);
    let enemies = ref([]);
    let gameOver = ref(false);
    let gameStarted = ref(false);

    let startTime = 0;
    let elapsedTime = 0;
    let finalTimeText = '00:00.000';

    let rightPressed = false;
    let leftPressed = false;
    let upPressed = false;
    let downPressed = false;

    let enemySpawnInterval = INITIAL_ENEMY_SPAWN_INTERVAL;
    let frameCount = 0;
    let lastHitTime = 0;
    let animationFrameId = null;

    let isSpecialAttackActive = ref(false);
    let specialAttackTimer = 0;
    let nextSpecialTime = 0;

    let timeUntilNextSpecial = ref(0);

    let difficultyLevel = ref(1);

    // --- Èñ¢Êï∞ÂÆöÁæ© ---
    const resizeCanvas = () => {
      if (!canvas) return;
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      if (!gameStarted.value) {
        playerX.value = canvas.width / 2 - PLAYER_SIZE / 2;
        playerY.value = canvas.height / 2;
      }
    };

    const resetGame = () => {
      resizeCanvas();
      playerX.value = canvas.width / 2 - PLAYER_SIZE / 2;
      playerY.value = canvas.height / 2;
      playerHP.value = MAX_HP;

      enemies.value = [];
      gameOver.value = false;
      rightPressed = false;
      leftPressed = false;
      upPressed = false;
      downPressed = false;
      frameCount = 0;

      difficultyLevel.value = 1;
      enemySpawnInterval = INITIAL_ENEMY_SPAWN_INTERVAL;
      lastHitTime = 0;

      startTime = 0;
      elapsedTime = 0;
      finalTimeText = '00:00.000';

      isSpecialAttackActive.value = false;
      const now = Date.now();
      specialAttackTimer = now;
      nextSpecialTime = now + SPECIAL_ATTACK_INTERVAL;
      timeUntilNextSpecial.value = SPECIAL_ATTACK_INTERVAL;
    };

    const keyDownHandler = (e) => {
      if (e.key === 'Right' || e.key === 'ArrowRight') {
        rightPressed = true;
      } else if (e.key === 'Left' || e.key === 'ArrowLeft') {
        leftPressed = true;
      } else if (e.key === 'Up' || e.key === 'ArrowUp') {
        upPressed = true;
      } else if (e.key === 'Down' || e.key === 'ArrowDown') {
        downPressed = true;
      } else if (e.key === ' ' || e.key === 'Spacebar') {
        if (!gameStarted.value) {
          gameStarted.value = true;
          const now = Date.now();
          startTime = now;
          specialAttackTimer = now;
          nextSpecialTime = now + SPECIAL_ATTACK_INTERVAL;
          rightPressed = false;
          leftPressed = false;
        } else if (gameOver.value) {
          resetGame();
          gameStarted.value = true;
          const now = Date.now();
          startTime = now;
          specialAttackTimer = now;
          nextSpecialTime = now + SPECIAL_ATTACK_INTERVAL;
        }
      }
    };

    const keyUpHandler = (e) => {
      if (e.key === 'Right' || e.key === 'ArrowRight') {
        rightPressed = false;
      } else if (e.key === 'Left' || e.key === 'ArrowLeft') {
        leftPressed = false;
      } else if (e.key === 'Up' || e.key === 'ArrowUp') {
        upPressed = false;
      } else if (e.key === 'Down' || e.key === 'ArrowDown') {
        downPressed = false;
      }
    };

    const formatTime = (ms) => {
      const totalSeconds = Math.floor(ms / 1000);
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;
      const milliseconds = ms % 1000;

      const minStr = String(minutes).padStart(2, '0');
      const secStr = String(seconds).padStart(2, '0');
      const msStr = String(milliseconds).padStart(3, '0').slice(0, 3);
      return `${minStr}:${secStr}.${msStr}`;
    };

    const formatCountdown = (ms) => {
      const safeMs = Math.max(0, ms);
      const seconds = Math.floor(safeMs / 1000);
      const milliseconds = safeMs % 1000;

      const secStr = String(seconds);
      const msStr = String(milliseconds).padStart(3, '0').slice(0, 3);
      return `${secStr}.${msStr}`;
    };

    // --- ÊèèÁîªÈñ¢Êï∞ ---
    const drawPlayer = () => {
      const currentTime = Date.now();
      const isInvulnerable = currentTime - lastHitTime < INVULNERABILITY_TIME;

      if (isInvulnerable && Math.floor(currentTime / 100) % 2 === 0) {
        ctx.fillStyle = 'lightblue';
      } else {
        ctx.fillStyle = 'blue';
      }
      ctx.fillRect(playerX.value, playerY.value, PLAYER_SIZE, PLAYER_SIZE);
    };

    const drawEnemies = () => {
      enemies.value.forEach((enemy) => {
        if (enemy.type === 'bomb') {
          ctx.fillStyle = 'green';
        } else if (enemy.type === 'special') {
          ctx.fillStyle = 'purple';
        } else {
          ctx.fillStyle = 'red';
        }
        ctx.fillRect(enemy.x, enemy.y, enemy.size, enemy.size);
      });
    };

    const drawSpecialAttackWarning = () => {
      if (isSpecialAttackActive.value) {
        ctx.font = '36px Arial';
        ctx.fillStyle = 'rgba(255, 0, 0, 0.9)';
        ctx.textAlign = 'center';
        ctx.fillText('DANGER!!!', canvas.width / 2, canvas.height * 0.2);
      }
    };

    const drawScoreAndHP = () => {
      ctx.font = '20px Arial';
      ctx.fillStyle = '#333';

      ctx.textAlign = 'left';
      const hpText = 'HP: ' + '‚ù§Ô∏è'.repeat(playerHP.value);
      ctx.fillText(hpText, 10, 30);

      ctx.fillText(`Lv: ${difficultyLevel.value}`, 10, 60);

      ctx.textAlign = 'right';
      const timeText = formatTime(elapsedTime);
      ctx.fillText('Time: ' + timeText, canvas.width - 10, 30);

      ctx.textAlign = 'center';
      let countdownText = '---';
      if (!isSpecialAttackActive.value) {
        countdownText = formatCountdown(timeUntilNextSpecial.value);
        ctx.fillStyle = timeUntilNextSpecial.value < 3000 ? 'red' : '#333';
      } else {
        countdownText = 'NOW!';
        ctx.fillStyle = 'red';
      }

      ctx.fillText('ÂøÖÊÆ∫ÊäÄ„Ç´„Ç¶„É≥„Éà: ' + countdownText, canvas.width / 2, 30);
    };

    const drawStartScreen = () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      ctx.font = '40px Arial';
      ctx.fillStyle = 'black';
      ctx.textAlign = 'center';
      ctx.fillText('ÈÅø„Åë„Çã„Ç≤„Éº„É†', canvas.width / 2, canvas.height / 2 - 80);

      ctx.font = '24px Arial';
      ctx.fillStyle = '#555';
      ctx.fillText(
        '‚Üë ‚Üì ‚Üê ‚Üí „Ç≠„Éº„ÅßÊìç‰Ωú',
        canvas.width / 2,
        canvas.height / 2 - 20
      );

      ctx.font = '30px Arial';
      ctx.fillStyle = 'blue';
      ctx.fillText(
        '„Çπ„Éö„Éº„Çπ„Ç≠„Éº„Åß„Çπ„Çø„Éº„Éà',
        canvas.width / 2,
        canvas.height / 2 + 40
      );

      ctx.font = '20px Arial';
      ctx.fillStyle = 'darkgreen';
      ctx.fillText(
        '10Áßí„Åî„Å®„Å´ÁîªÈù¢‰∏äÈÉ®„Åã„Çâ„ÅÆÂøÖÊÆ∫ÊäÄÁô∫ÂãïÔºÅ(Lv3, 6, 9„ÅßÁô∫Â∞ÑÊñπÂêë„ÅåÂ¢ó„Åà„Çã)',
        canvas.width / 2,
        canvas.height / 2 + 90
      );

      ctx.fillText(
        'ÂøÖÊÆ∫ÊäÄ„ÅÆÂæå„Å´„ÅØÈõ£ÊòìÂ∫¶„Åå‰∏ä„Åå„Çä„ÄÅHP„ÇÇ1ÂõûÂæ©„Åô„Çã„ÅûÔºÅ',
        canvas.width / 2,
        canvas.height / 2 + 120
      );
    };

    const drawGameOver = () => {
      ctx.font = '40px Arial';
      ctx.textAlign = 'center';

      if (elapsedTime >= 120000) {
        ctx.fillStyle = 'gold';
        ctx.fillText(
          'Âà∂‰ΩúËÄÖË∂ä„Åà„ÅÆÂº∑ËÄÖÁèæ„ÇãÔºÅŒ£(ÔΩ•œâÔΩ•Ôæâ)ÔæâÔºÅüèÜ‚ú®',
          canvas.width / 2,
          canvas.height / 2 - 60
        );
        ctx.font = '36px Arial';
        ctx.fillStyle = 'red';
        ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2);
      } else if (elapsedTime >= 90000) {
        ctx.fillStyle = 'purple';
        ctx.fillText(
          'Âà∂‰ΩúËÄÖ„ÇÇ„Åì„Çå„Å´„ÅØ‚úå(^O^)‚úåüèÜ',
          canvas.width / 2,
          canvas.height / 2 - 60
        );
        ctx.font = '36px Arial';
        ctx.fillStyle = 'red';
        ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2);
      } else if (elapsedTime >= 60000) {
        ctx.fillStyle = 'orange';
        ctx.fillText(
          '„Åä„ÅäÔºÅ1ÂàÜË∂ä„ÅàÔºÅ„Åô„Åî„ÅÑÔºÅüéâ',
          canvas.width / 2,
          canvas.height / 2 - 60
        );
        ctx.font = '36px Arial';
        ctx.fillStyle = 'red';
        ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2);
      } else {
        ctx.fillStyle = 'red';
        ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2);
      }

      ctx.font = '30px Arial';
      ctx.fillStyle = '#333';

      const scoreYOffset = 50;
      ctx.fillText(
        'Time Survived: ' + finalTimeText,
        canvas.width / 2,
        canvas.height / 2 + scoreYOffset
      );

      ctx.font = '26px Arial';
      ctx.fillStyle = 'blue';

      const restartYOffset = 100;
      ctx.fillText(
        '„Çπ„Éö„Éº„Çπ„Ç≠„Éº„Åß„É™„Çπ„Çø„Éº„Éà',
        canvas.width / 2,
        canvas.height / 2 + restartYOffset
      );
    };

    // --- „Ç≤„Éº„É†„É≠„Ç∏„ÉÉ„ÇØ ---
    const movePlayer = () => {
      if (rightPressed && playerX.value < canvas.width - PLAYER_SIZE) {
        playerX.value += PLAYER_SPEED;
      } else if (leftPressed && playerX.value > 0) {
        playerX.value -= PLAYER_SPEED;
      }
      if (upPressed && playerY.value > 0) {
        playerY.value -= PLAYER_SPEED;
      } else if (downPressed && playerY.value < canvas.height - PLAYER_SIZE) {
        playerY.value += PLAYER_SPEED;
      }
    };

    const activateSpecialAttack = () => {
      isSpecialAttackActive.value = true;
      enemies.value = [];

      // ‚òÖ ‰øÆÊ≠£ÁÇπ: ÂÆöÊï∞„Å®„Åó„Å¶ÂÆöÁæ©„Åó„ÅüBASE_BULLETS_PER_SIDE„Çí‰ΩøÁî®
      // const NUM_BULLETS = 60; // ‰ª•Ââç„ÅÆÂÄ§
      const SPECIAL_BULLET_SIZE = 5;
      const SPECIAL_BULLET_SPEED = 3.5;

      // „É¨„Éô„É´„Å´Âøú„Åò„Å¶„ÄÅÁô∫Â∞Ñ„Åô„Çã„Çµ„Ç§„Éâ„ÇíÊ±∫ÂÆö
      const activeSides = [];
      activeSides.push(0); // „Éô„Éº„Çπ„ÅØÂ∏∏„Å´‰∏ä„Åã„Çâ

      const level = difficultyLevel.value;

      // „É¨„Éô„É´3‰ª•‰∏ä„ÅßÂè≥„ÇíËøΩÂä†
      if (level >= 3) {
        activeSides.push(1);
      }
      // „É¨„Éô„É´6‰ª•‰∏ä„ÅßÂ∑¶„ÇíËøΩÂä†
      if (level >= 6) {
        activeSides.push(2);
      }
      // „É¨„Éô„É´9‰ª•‰∏ä„Åß‰∏ã„ÇíËøΩÂä†
      if (level >= 9) {
        activeSides.push(3);
      }

      // Âºæ„ÇíÁîüÊàê
      activeSides.forEach((side) => {
        let startX, startY, minAngle, maxAngle;
        let numBullets = BASE_BULLETS_PER_SIDE; // ÂêÑ„Çµ„Ç§„Éâ„ÅÆÂºæÊï∞„ÅÆÂàùÊúüÂÄ§

        if (side === 0) {
          // ‰∏ä„Åã„Çâ‰∏ã („Éô„Éº„ÇπÊï∞)
          startX = canvas.width / 2;
          startY = 0;
          minAngle = (Math.PI * 1) / 12; // 15Â∫¶
          maxAngle = (Math.PI * 11) / 12; // 165Â∫¶
          numBullets = BASE_BULLETS_PER_SIDE;
        } else if (side === 1) {
          // Âè≥„Åã„ÇâÂ∑¶ („É¨„Éô„É´3„ÅßËøΩÂä†)
          startX = canvas.width;
          startY = canvas.height / 2;
          minAngle = (Math.PI * 7) / 12; // 105Â∫¶
          maxAngle = (Math.PI * 17) / 12; // 255Â∫¶
          // ‚òÖ Â∑¶Âè≥„ÅÆÂºæÊï∞„Çí„Éô„Éº„Çπ„ÅÆ75%„Å´Ë®≠ÂÆö
          numBullets = Math.floor(BASE_BULLETS_PER_SIDE * 0.8);
        } else if (side === 2) {
          // Â∑¶„Åã„ÇâÂè≥ („É¨„Éô„É´6„ÅßËøΩÂä†)
          startX = 0;
          startY = canvas.height / 2;
          minAngle = (Math.PI * -5) / 12; // -75Â∫¶ (285Â∫¶)
          maxAngle = (Math.PI * 5) / 12; // 75Â∫¶
          // ‚òÖ Â∑¶Âè≥„ÅÆÂºæÊï∞„Çí„Éô„Éº„Çπ„ÅÆ75%„Å´Ë®≠ÂÆö
          numBullets = Math.floor(BASE_BULLETS_PER_SIDE * 0.8);
        } else if (side === 3) {
          // ‰∏ã„Åã„Çâ‰∏ä („É¨„Éô„É´9„ÅßËøΩÂä†)
          startX = canvas.width / 2;
          startY = canvas.height;
          minAngle = (Math.PI * 13) / 12; // 195Â∫¶
          maxAngle = (Math.PI * 23) / 12; // 345Â∫¶
          // ‚òÖ ‰∏ã„ÅÆÂºæÊï∞„Çí„Éô„Éº„Çπ„ÅÆ50%„Å´Ë®≠ÂÆö
          numBullets = Math.floor(BASE_BULLETS_PER_SIDE * 0.5);
        }

        // ÂêÑ„Çµ„Ç§„Éâ„ÅßÂºæ„ÇíÁîüÊàê
        for (let i = 0; i < numBullets; i++) {
          const angle = minAngle + Math.random() * (maxAngle - minAngle);
          const speed = SPECIAL_BULLET_SPEED + Math.random() * 2;

          enemies.value.push({
            x: startX,
            y: startY,
            size: SPECIAL_BULLET_SIZE,
            speedX: Math.cos(angle) * speed,
            speedY: Math.sin(angle) * speed,
            type: 'special',
          });
        }
      });

      setTimeout(() => {
        isSpecialAttackActive.value = false;
        difficultyLevel.value++;

        if (playerHP.value < MAX_HP) {
          playerHP.value++;
        }

        enemySpawnInterval = Math.max(
          5,
          INITIAL_ENEMY_SPAWN_INTERVAL - (difficultyLevel.value - 1) * 5
        );

        const now = Date.now();
        specialAttackTimer = now;
        nextSpecialTime = now + SPECIAL_ATTACK_INTERVAL;

        enemies.value = [];
      }, SPECIAL_ATTACK_DURATION);
    };

    const spawnEnemy = () => {
      const now = Date.now();

      if (isSpecialAttackActive.value) {
        frameCount++;
        return;
      }

      // 10Áßí„Åî„Å®„ÅÆÂøÖÊÆ∫ÊäÄ„ÉÅ„Çß„ÉÉ„ÇØ
      timeUntilNextSpecial.value = nextSpecialTime - now;

      if (now - specialAttackTimer > SPECIAL_ATTACK_INTERVAL) {
        activateSpecialAttack();
        return;
      }

      if (frameCount % enemySpawnInterval === 0) {
        const rand = Math.random();
        // 0:‰∏ä„Åã„Çâ, 1:Â∑¶„Åã„Çâ, 2:Âè≥„Åã„Çâ (‰∏ä„Åã„Çâ„ÅÆÊïµ„ÇíÂ§ö„ÇÅ„Å´)
        const spawnSide = Math.floor(Math.random() * 3);
        let enemyData = {};
        const ENEMY_SIZE = 10;
        const difficultyMultiplier = 1 + (difficultyLevel.value - 1) * 0.2;
        const ENEMY_SPEED =
          (BASE_ENEMY_SPEED + Math.random() * 3) * difficultyMultiplier;

        if (rand < 0.15) {
          // ÁàÜÂºæ„Çø„Ç§„Éó„ÅÆÊïµ
          enemyData = {
            x: Math.random() * (canvas.width - 50),
            y: -50,
            size: 50,
            speedX: 0,
            speedY:
              (BASE_ENEMY_SPEED + Math.random() * 1.5) * difficultyMultiplier,
            type: 'bomb',
            hasExploded: false,
          };
        } else {
          // ÈÄöÂ∏∏„ÅÆÊïµ
          if (spawnSide === 0) {
            // ‰∏ä„Åã„ÇâÂá∫Áèæ
            enemyData = {
              x: Math.random() * (canvas.width - ENEMY_SIZE),
              y: -ENEMY_SIZE,
              size: ENEMY_SIZE,
              speedX: 0,
              speedY: ENEMY_SPEED,
              type: 'normal',
            };
          } else if (spawnSide === 1) {
            // Â∑¶„Åã„ÇâÂá∫Áèæ (Á∏¶ÁßªÂãï„ÇíËøΩÂä†„Åó„Å¶ÂÆâÂÖ®Âú∞Â∏Ø„ÇíËß£Ê∂à)
            const randomSpeedY = (Math.random() - 0.5) * ENEMY_SPEED * 0.5;
            enemyData = {
              x: -ENEMY_SIZE,
              y: Math.random() * (canvas.height - ENEMY_SIZE),
              size: ENEMY_SIZE,
              speedX: ENEMY_SPEED * 0.8,
              speedY: randomSpeedY,
            };
          } else {
            // Âè≥„Åã„ÇâÂá∫Áèæ (Á∏¶ÁßªÂãï„ÇíËøΩÂä†„Åó„Å¶ÂÆâÂÖ®Âú∞Â∏Ø„ÇíËß£Ê∂à)
            const randomSpeedY = (Math.random() - 0.5) * ENEMY_SPEED * 0.5;
            enemyData = {
              x: canvas.width,
              y: Math.random() * (canvas.height - ENEMY_SIZE),
              size: ENEMY_SIZE,
              speedX: -ENEMY_SPEED * 0.8,
              speedY: randomSpeedY,
            };
          }
        }
        enemies.value.push(enemyData);
      }
      frameCount++;
    };

    const updateEnemies = () => {
      for (let i = 0; i < enemies.value.length; i++) {
        if (enemies.value[i].speedX)
          enemies.value[i].x += enemies.value[i].speedX;
        if (enemies.value[i].speedY)
          enemies.value[i].y += enemies.value[i].speedY;

        const currentEnemy = enemies.value[i];

        if (
          currentEnemy.type === 'bomb' &&
          !currentEnemy.hasExploded &&
          currentEnemy.y > canvas.height / 4
        ) {
          const numFragments = 3 + Math.floor(Math.random() * 5);
          for (let j = 0; j < numFragments; j++) {
            enemies.value.push({
              x:
                currentEnemy.x + currentEnemy.size / 2 - 5 + Math.random() * 10,
              y: currentEnemy.y,
              size: 5 + Math.random() * 5,
              speedX: (Math.random() - 0.5) * 5,
              speedY: 3 + Math.random() * 3,
              type: 'fragment',
            });
          }
          currentEnemy.hasExploded = true;
          enemies.value.splice(i, 1);
          i--;
          continue;
        }

        const isOutOfBoundsY =
          currentEnemy.y > canvas.height + 50 ||
          currentEnemy.y < -currentEnemy.size - 50;
        const isOutOfBoundsX =
          currentEnemy.x > canvas.width + 50 ||
          currentEnemy.x < -currentEnemy.size - 50;

        // Êïµ„ÅåÁîªÈù¢Â§ñ„Å´Âá∫„Åü„ÇâÂâäÈô§
        if (isOutOfBoundsY || isOutOfBoundsX) {
          enemies.value.splice(i, 1);
          i--;
        }
      }
    };

    const checkCollision = () => {
      const currentTime = Date.now();
      if (currentTime - lastHitTime < INVULNERABILITY_TIME) {
        return;
      }

      for (let i = 0; i < enemies.value.length; i++) {
        const enemy = enemies.value[i];
        if (
          playerX.value < enemy.x + enemy.size &&
          playerX.value + PLAYER_SIZE > enemy.x &&
          playerY.value < enemy.y + enemy.size &&
          playerY.value + PLAYER_SIZE > enemy.y
        ) {
          playerHP.value -= 1;
          lastHitTime = currentTime;

          if (playerHP.value <= 0) {
            gameOver.value = true;
            finalTimeText = formatTime(elapsedTime);
            cancelAnimationFrame(animationFrameId);
          }
          break; // Ë°ùÁ™Å„Åó„Åü„Çâ„É´„Éº„Éó„ÇíÊäú„Åë„Çã (1„Éï„É¨„Éº„É†1„Éí„ÉÉ„Éà„ÇíÊÉ≥ÂÆö)
        }
      }
    };

    // --- „É°„Ç§„É≥„Ç≤„Éº„É†„É´„Éº„Éó ---
    const gameLoop = () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (!gameStarted.value) {
        drawStartScreen();
      } else if (!gameOver.value) {
        elapsedTime = Date.now() - startTime;

        movePlayer();
        spawnEnemy();
        updateEnemies();
        checkCollision();

        drawPlayer();
        drawEnemies();
        drawSpecialAttackWarning();
        drawScoreAndHP();
      } else {
        drawGameOver();
      }

      animationFrameId = requestAnimationFrame(gameLoop);
    };

    // --- „É©„Ç§„Éï„Çµ„Ç§„ÇØ„É´„Éï„ÉÉ„ÇØ ---
    onMounted(() => {
      canvas = gameCanvas.value;
      if (!canvas) return;
      ctx = canvas.getContext('2d');

      resetGame();
      gameLoop();

      document.addEventListener('keydown', keyDownHandler, false);
      document.addEventListener('keyup', keyUpHandler, false);
      window.addEventListener('resize', resizeCanvas);
    });

    onUnmounted(() => {
      cancelAnimationFrame(animationFrameId);
      document.removeEventListener('keydown', keyDownHandler);
      document.removeEventListener('keyup', keyUpHandler);
      window.removeEventListener('resize', resizeCanvas);
    });

    return {
      gameCanvas,
    };
  },
};
</script>

<style scoped>
/*
  „Äê„Ç≠„É£„É≥„Éê„ÇπË°®Á§∫„Ç®„É™„Ç¢„ÅÆË®≠ÂÆö„Äë
  „Ç≤„Éº„É†„Ç®„É™„Ç¢ÂÖ®‰Ωì„ÇíÁîªÈù¢„Å´Âõ∫ÂÆö„Åó„ÄÅ„Ç≠„É£„É≥„Éê„Çπ„Çí„Åù„ÅÆ‰∏≠„Å´ÈÖçÁΩÆ
*/
.game-container {
  margin: 0;
  overflow: hidden; /* „Çπ„ÇØ„É≠„Éº„É´„ÇíÁ¶ÅÊ≠¢ */
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh; /* „Éì„É•„Éº„Éù„Éº„Éà„ÅÆÈ´ò„ÅïÂÖ®‰Ωì */
  width: 100vw; /* „Éì„É•„Éº„Éù„Éº„Éà„ÅÆÂπÖÂÖ®‰Ωì */
  background-color: #f0f0f0;
  position: fixed; /* „Ç≤„Éº„É†ÁîªÈù¢ÂÖ®‰Ωì„ÇíÂõ∫ÂÆö */
  top: 0;
  left: 0;
  z-index: 1; /* „Ç≠„É£„É≥„Éê„Çπ„ÅØ„É¨„Ç§„É§„Éº1 */
}

canvas {
  border: 2px solid #333;
  background-color: #fff;
  width: 100vw;
  height: 100vh;
}

/* „Äê„Éõ„Éº„É†„Éú„Çø„É≥‰ΩçÁΩÆ„ÅÆ‰øÆÊ≠£„Äë
  „Éõ„Éº„É†„Éú„Çø„É≥„ÇíHPË°®Á§∫„ÅÆÂè≥Èö£ („Çà„Çä‰∏ä) „Å´Âõ∫ÂÆöÈÖçÁΩÆ
*/
.home-button-corner {
  /* „Éú„Çø„É≥„Ç≥„É≥„ÉÜ„Éä„ÇíÁîªÈù¢‰∏ä„Å´Âõ∫ÂÆö */
  position: fixed;
  /* HPË°®Á§∫ (YÂ∫ßÊ®ô 30px) „ÅÆÈö£„Å´ÈÖçÁΩÆ */
  top: 25px; /* HPË°®Á§∫„ÅÆÁ∏¶‰ΩçÁΩÆ„Å´Âêà„Çè„Åõ„Çã„Åü„ÇÅ„ÄÅ25px„Å´Ë®≠ÂÆö */
  left: 60px; /* HPË°®Á§∫„ÅÆÊ®™ÂπÖ„ÅÆÂæå„Å´ÈÖçÁΩÆ */
  z-index: 10; /* „Ç≠„É£„É≥„Éê„Çπ„Çà„ÇäÂâçÈù¢ (z-index: 1) „Å´Ë°®Á§∫ */
}

.home-button-corner button {
  padding: 5px 10px;
  font-size: 14px;
  cursor: pointer;
  border: 1px solid #333;
  background-color: #eee;
  color: #333;
  border-radius: 4px;
}
</style>
